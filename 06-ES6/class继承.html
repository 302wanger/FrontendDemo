<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>继承</title>
</head>
<body>

<script>
    /*    class A {
            constructor() {
                this.va = 'va'
                this.fa = function f1() {
                    console.log('f1')
                    console.log(this)
                }
            }


            f2() {
                console.log('f2')
                console.log(this)
            }
        }

        let a = new A();
        a.fa();
        a.f2();

        console.log(1, A.prototype);
        console.log(1, A.constructor.prototype);
        console.log(A.__proto__);*/


    //只有super方法才能调用父类实例。
    // super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B
    /* class Point {
         constructor(x, y) {
             this.x = x;
             this.y = y;
         }
     }


     class ColorPoint extends Point {
         constructor(x, y, color) {
             //  this.color = color; // ReferenceError
             // super(x, y);
             console.log(super());
             console.log(this);
             this.color = color; // 正确
         }
     }

     let color = new ColorPoint(1, 2, 'heis');
     console.log(color.constructor.prototype)
     console.log(color.prototype)
     console.log(color.y)
     console.log(color.color)*/


    // super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

    /*    class A {
            p() {
                return 2;
            }

            constructor(x) {
                this.d = function (x) {
                    return x
                }
            }
        }

        class B extends A {
            constructor() {
                super();
                console.log(super.p()); // 2

                console.log(super.d()); // 娶不到
            }
        }

        console.log(A)
        console.log(A.prototype)
        console.log(A.prototype.constructor.__proto__)
        let b = new B(3);*/

    class Parent {
        static myMethod(msg) {
            console.log('static', msg);
        }

        myMethod(msg) {
            console.log('instance', msg);
        }
    }

    class Child extends Parent {
        static myMethod(msg) {
            super.myMethod(msg);
        }

        myMethod(msg) {

            super.myMethod(msg);
        }
    }

    Child.myMethod(1); // static 1 静态方法是直接在类上调用，在实例里面调用不到的，会报错

    var child = new Child();
    child.myMethod(2); // instance 2

</script>
</body>
</html>