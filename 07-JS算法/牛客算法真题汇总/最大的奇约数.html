<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    /**
     * 题目： 小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数f(x)为x最大的奇数约数，x为正整数。 例如:f(44) = 11.
     现在给出一个N，需要求出 f(1) + f(2) + f(3).......f(N)
     例如： N = 7
     f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21
     小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。
     *
     * 1<= n <= 1000000000
     *
     *
     * 分析：如果这个数为奇数，则最大约数为他自己本身，
     *      如果是偶数，则除2，结果如果是奇数，则返回，如果是偶数，则继续，直到返回奇数
     *
     *
     * **/
    let res = [];
    let sum = 0;

    // function maxOddSum(n) {
    //     if ((n % 2) !== 0) { // 奇数
    //         sum += Math.pow((n + 1) / 2, 2);
    //         for (let i = 2; i <= n - 1; i += 2) {
    //             sum += maxOdd(i);
    //         }
    //     } else { // 偶数
    //         sum += Math.pow(n / 2, 2);
    //         for (let i = 2; i <= n; i += 2) {
    //             sum += maxOdd(i);
    //         }
    //     }
    //
    //     return sum;
    // }
    //
    // function maxOdd(n) {
    //     if ((n % 2) !== 0) {
    //         return n
    //     } else {
    //         // if (Number.isInteger(n / 16)) {
    //         //     return maxOdd(n / 16)
    //         // } else if (Number.isInteger(n / 8)) {
    //         //     return maxOdd(n / 8)
    //         // } else if (Number.isInteger(n / 4)) {
    //         //     return maxOdd(n / 4)
    //         // } else if (Number.isInteger(n / 2)) {
    //         //     return maxOdd(n / 2)
    //         // }
    //         return maxOdd(n / 2)
    //     }
    //
    // }


    // 递归方法

    function fio(n) {
        if (n === 1) {
            return 1
        } else {
            if (n % 2 === 0) {
                sum += Math.pow(n / 2, 2);
            }
        }
    }

    console.log(maxOddSum(7));
</script>
</body>
</html>